{
  "version": 3,
  "sources": ["../src/types.ts", "../src/globals.ts", "../src/utils.ts", "../src/workletStringCode.ts", "../src/workletFactory.ts", "../src/workletFactoryCall.ts", "../src/workletSubstitution.ts", "../src/gestureHandlerAutoworkletization.ts", "../src/layoutAnimationAutoworkletization.ts", "../src/referencedWorklets.ts", "../src/objectWorklets.ts", "../src/autoworkletization.ts", "../src/inlineStylesWarning.ts", "../src/webOptimization.ts", "../src/plugin.ts"],
  "sourcesContent": ["import type { BabelFile, NodePath } from '@babel/core';\nimport type {\n  FunctionDeclaration,\n  FunctionExpression,\n  ObjectMethod,\n  ArrowFunctionExpression,\n  ObjectExpression,\n} from '@babel/types';\n\nexport interface ReanimatedPluginOptions {\n  relativeSourceLocation?: boolean;\n  disableInlineStylesWarning?: boolean;\n  processNestedWorklets?: boolean;\n  omitNativeOnlyData?: boolean;\n  globals?: string[];\n  substituteWebPlatformChecks?: boolean;\n}\n\nexport interface ReanimatedPluginPass {\n  file: BabelFile;\n  key: string;\n  opts: ReanimatedPluginOptions;\n  cwd: string;\n  filename: string | undefined;\n  get(key: unknown): unknown;\n  set(key: unknown, value: unknown): void;\n  [key: string]: unknown;\n}\n\nexport type WorkletizableFunction =\n  | FunctionDeclaration\n  | FunctionExpression\n  | ArrowFunctionExpression\n  | ObjectMethod;\n\nexport const WorkletizableFunction =\n  'FunctionDeclaration|FunctionExpression|ArrowFunctionExpression|ObjectMethod';\n\nexport type WorkletizableObject = ObjectExpression;\n\nexport const WorkletizableObject = 'ObjectExpression';\n\nexport function isWorkletizableFunctionType(\n  path: NodePath<unknown>\n): path is NodePath<WorkletizableFunction> {\n  return (\n    path.isFunctionDeclaration() ||\n    path.isFunctionExpression() ||\n    path.isArrowFunctionExpression() ||\n    path.isObjectMethod()\n  );\n}\n\nexport function isWorkletizableObjectType(\n  path: NodePath<unknown>\n): path is NodePath<WorkletizableObject> {\n  return path.isObjectExpression();\n}\n", "const notCapturedIdentifiers = [\n  // Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\n\n  // Note that objects' properties don't need to be listed since we always only capture the whole object,\n  // e.g. `global.__ErrorUtils` or `Intl.DateTimeFormat`.\n\n  // Value properties\n  'globalThis',\n  'Infinity',\n  'NaN',\n  'undefined',\n\n  // Function properties\n  'eval',\n  'isFinite',\n  'isNaN',\n  'parseFloat',\n  'parseInt',\n  'decodeURI',\n  'decodeURIComponent',\n  'encodeURI',\n  'encodeURIComponent',\n  'escape',\n  'unescape',\n\n  // Fundamental objects\n  'Object',\n  'Function',\n  'Boolean',\n  'Symbol',\n\n  // Error objects\n  'Error',\n  'AggregateError',\n  'EvalError',\n  'RangeError',\n  'ReferenceError',\n  'SyntaxError',\n  'TypeError',\n  'URIError',\n  'InternalError',\n\n  // Numbers and dates\n  'Number',\n  'BigInt',\n  'Math',\n  'Date',\n\n  // Text processing\n  'String',\n  'RegExp',\n\n  // Indexed collections\n  'Array',\n  'Int8Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Int16Array',\n  'Uint16Array',\n  'Int32Array',\n  'Uint32Array',\n  'BigInt64Array',\n  'BigUint64Array',\n  'Float32Array',\n  'Float64Array',\n\n  // Keyed collections\n  'Map',\n  'Set',\n  'WeakMap',\n  'WeakSet',\n\n  // Structured data\n  'ArrayBuffer',\n  'SharedArrayBuffer',\n  'DataView',\n  'Atomics',\n  'JSON',\n\n  // Managing memory\n  'WeakRef',\n  'FinalizationRegistry',\n\n  // Control abstraction objects\n  'Iterator',\n  'AsyncIterator',\n  'Promise',\n  'GeneratorFunction',\n  'AsyncGeneratorFunction',\n  'Generator',\n  'AsyncGenerator',\n  'AsyncFunction',\n\n  // Reflection\n  'Reflect',\n  'Proxy',\n\n  // Internationalization\n  'Intl',\n\n  // Other stuff\n  'null',\n  'this',\n  'global',\n  'console',\n  'performance',\n  'queueMicrotask',\n  'requestAnimationFrame',\n  'setImmediate',\n  'arguments', // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments\n\n  // Hermes\n  'HermesInternal',\n\n  // Reanimated\n  '_WORKLET',\n];\n\n/**\n * @deprecated Since we moved on to using `global.` prefix in Reanimated, we don't need to\n * capture these identifiers anymore. However, for safety reasons and 3rd party libraries,\n * we still keep them in the list.\n *\n * `_WORKLET` is the only exception since it's a part of the public API.\n */\n// eslint-disable-next-line camelcase\nconst notCapturedIdentifiers_DEPRECATED = [\n  // Reanimated\n  '_IS_FABRIC',\n  '_log',\n  '_toString',\n  '_scheduleOnJS',\n  '_scheduleOnRuntime',\n  '_makeShareableClone',\n  '_updatePropsPaper',\n  '_updatePropsFabric',\n  '_removeFromPropsRegistry',\n  '_measurePaper',\n  '_measureFabric',\n  '_scrollToPaper',\n  '_dispatchCommandPaper',\n  '_dispatchCommandFabric',\n  '_setGestureState',\n  '_notifyAboutProgress',\n  '_notifyAboutEnd',\n  '_runOnUIQueue',\n  '_getAnimationTimestamp',\n];\n\nexport const defaultGlobals = new Set(\n  notCapturedIdentifiers.concat(notCapturedIdentifiers_DEPRECATED)\n);\n\nexport let globals: Set<string>;\n\nexport function initializeGlobals() {\n  globals = new Set(defaultGlobals);\n}\n", "import { globals } from './globals';\nimport type { ReanimatedPluginPass } from './types';\n\nexport function isRelease() {\n  const pattern = /(prod|release|stag[ei])/i;\n  return !!(\n    process.env.BABEL_ENV?.match(pattern) ||\n    process.env.NODE_ENV?.match(pattern)\n  );\n}\n\n/**\n * This function allows to add custom globals such as host-functions.\n * Those globals have to be passed as an argument for the plugin in babel.config.js.\n *\n * For example: `plugins: [['react-native-reanimated/plugin', { globals: ['myHostFunction'] }]]`\n */\nexport function addCustomGlobals(this: ReanimatedPluginPass) {\n  if (this.opts && Array.isArray(this.opts.globals)) {\n    this.opts.globals.forEach((name: string) => {\n      globals.add(name);\n    });\n  }\n}\n", "import type { BabelFileResult, NodePath, PluginItem } from '@babel/core';\nimport { transformSync } from '@babel/core';\nimport generate from '@babel/generator';\nimport type {\n  File as BabelFile,\n  ExpressionStatement,\n  FunctionDeclaration,\n  Identifier,\n  VariableDeclaration,\n} from '@babel/types';\nimport {\n  functionExpression,\n  identifier,\n  isArrowFunctionExpression,\n  isBlockStatement,\n  isExpression,\n  isExpressionStatement,\n  isFunctionDeclaration,\n  isObjectMethod,\n  isProgram,\n  memberExpression,\n  objectPattern,\n  objectProperty,\n  thisExpression,\n  variableDeclaration,\n  variableDeclarator,\n} from '@babel/types';\nimport { strict as assert } from 'assert';\nimport * as convertSourceMap from 'convert-source-map';\nimport * as fs from 'fs';\nimport { isRelease } from './utils';\nimport type { WorkletizableFunction } from './types';\n\nconst MOCK_SOURCE_MAP = 'mock source map';\n\nexport function buildWorkletString(\n  fun: BabelFile,\n  closureVariables: Array<Identifier>,\n  name: string,\n  inputMap: BabelFileResult['map']\n): Array<string | null | undefined> {\n  const draftExpression = (fun.program.body.find((obj) =>\n    isFunctionDeclaration(obj)\n  ) ||\n    fun.program.body.find((obj) => isExpressionStatement(obj)) ||\n    undefined) as FunctionDeclaration | ExpressionStatement | undefined;\n\n  assert(draftExpression, '[Reanimated] `draftExpression` is undefined.');\n\n  const expression = isFunctionDeclaration(draftExpression)\n    ? draftExpression\n    : draftExpression.expression;\n\n  assert(\n    'params' in expression,\n    \"'params' property is undefined in 'expression'\"\n  );\n  assert(\n    isBlockStatement(expression.body),\n    '[Reanimated] `expression.body` is not a `BlockStatement`'\n  );\n\n  const workletFunction = functionExpression(\n    identifier(name),\n    expression.params,\n    expression.body,\n    expression.generator,\n    expression.async\n  );\n\n  const code = generate(workletFunction).code;\n\n  assert(inputMap, '[Reanimated] `inputMap` is undefined.');\n\n  const includeSourceMap = !isRelease();\n\n  if (includeSourceMap) {\n    // Clear contents array (should be empty anyways)\n    inputMap.sourcesContent = [];\n    // Include source contents in source map, because Flipper/iframe is not\n    // allowed to read files from disk.\n    for (const sourceFile of inputMap.sources) {\n      inputMap.sourcesContent.push(\n        fs.readFileSync(sourceFile).toString('utf-8')\n      );\n    }\n  }\n\n  const transformed = transformSync(code, {\n    plugins: [prependClosureVariablesIfNecessary(closureVariables)],\n    compact: true,\n    sourceMaps: includeSourceMap,\n    inputSourceMap: inputMap,\n    ast: false,\n    babelrc: false,\n    configFile: false,\n    comments: false,\n  });\n\n  assert(transformed, '[Reanimated] `transformed` is null.');\n\n  let sourceMap;\n  if (includeSourceMap) {\n    if (shouldMockSourceMap()) {\n      sourceMap = MOCK_SOURCE_MAP;\n    } else {\n      sourceMap = convertSourceMap.fromObject(transformed.map).toObject();\n      // sourcesContent field contains a full source code of the file which contains the worklet\n      // and is not needed by the source map interpreter in order to symbolicate a stack trace.\n      // Therefore, we remove it to reduce the bandwith and avoid sending it potentially multiple times\n      // in files that contain multiple worklets. Along with sourcesContent.\n      delete sourceMap.sourcesContent;\n    }\n  }\n\n  return [transformed.code, JSON.stringify(sourceMap)];\n}\n\nfunction shouldMockSourceMap() {\n  // We don't want to pollute tests with source maps so we mock it\n  // for all tests (except one)\n  return process.env.REANIMATED_JEST_SHOULD_MOCK_SOURCE_MAP === '1';\n}\n\nfunction prependClosure(\n  path: NodePath<WorkletizableFunction>,\n  closureVariables: Array<Identifier>,\n  closureDeclaration: VariableDeclaration\n) {\n  if (closureVariables.length === 0 || !isProgram(path.parent)) {\n    return;\n  }\n\n  if (!isExpression(path.node.body)) {\n    path.node.body.body.unshift(closureDeclaration);\n  }\n}\n\nfunction prependRecursiveDeclaration(path: NodePath<WorkletizableFunction>) {\n  if (\n    isProgram(path.parent) &&\n    !isArrowFunctionExpression(path.node) &&\n    !isObjectMethod(path.node) &&\n    path.node.id &&\n    path.scope.parent\n  ) {\n    const hasRecursiveCalls =\n      path.scope.parent.bindings[path.node.id.name]?.references > 0;\n    if (hasRecursiveCalls) {\n      path.node.body.body.unshift(\n        variableDeclaration('const', [\n          variableDeclarator(\n            identifier(path.node.id.name),\n            memberExpression(thisExpression(), identifier('_recur'))\n          ),\n        ])\n      );\n    }\n  }\n}\n\nfunction prependClosureVariablesIfNecessary(\n  closureVariables: Array<Identifier>\n): PluginItem {\n  const closureDeclaration = variableDeclaration('const', [\n    variableDeclarator(\n      objectPattern(\n        closureVariables.map((variable) =>\n          objectProperty(\n            identifier(variable.name),\n            identifier(variable.name),\n            false,\n            true\n          )\n        )\n      ),\n      memberExpression(thisExpression(), identifier('__closure'))\n    ),\n  ]);\n\n  return {\n    visitor: {\n      'FunctionDeclaration|FunctionExpression|ArrowFunctionExpression|ObjectMethod':\n        (path: NodePath<WorkletizableFunction>) => {\n          prependClosure(path, closureVariables, closureDeclaration);\n          prependRecursiveDeclaration(path);\n        },\n    },\n  };\n}\n", "/* eslint-disable @typescript-eslint/no-var-requires */\nimport type { NodePath } from '@babel/core';\nimport { transformSync, traverse } from '@babel/core';\nimport generate from '@babel/generator';\nimport type {\n  File as BabelFile,\n  ExpressionStatement,\n  FunctionExpression,\n  Identifier,\n  ReturnStatement,\n  VariableDeclaration,\n} from '@babel/types';\nimport {\n  arrayExpression,\n  assignmentExpression,\n  blockStatement,\n  cloneNode,\n  expressionStatement,\n  functionExpression,\n  identifier,\n  isBlockStatement,\n  isFunctionDeclaration,\n  isFunctionExpression,\n  isIdentifier,\n  isMemberExpression,\n  isObjectExpression,\n  isObjectMethod,\n  isObjectProperty,\n  memberExpression,\n  newExpression,\n  numericLiteral,\n  objectExpression,\n  objectProperty,\n  returnStatement,\n  stringLiteral,\n  variableDeclaration,\n  variableDeclarator,\n} from '@babel/types';\nimport { strict as assert } from 'assert';\nimport { relative } from 'path';\nimport { buildWorkletString } from './workletStringCode';\nimport { globals } from './globals';\nimport type { ReanimatedPluginPass, WorkletizableFunction } from './types';\nimport { isRelease } from './utils';\n\nconst REAL_VERSION = require('../../package.json').version;\nconst MOCK_VERSION = 'x.y.z';\n\nconst workletStringTransformPresets = [\n  require.resolve('@babel/preset-typescript'),\n];\n\nconst workletStringTransformPlugins = [\n  require.resolve('@babel/plugin-transform-shorthand-properties'),\n  require.resolve('@babel/plugin-transform-arrow-functions'),\n  require.resolve('@babel/plugin-transform-optional-chaining'),\n  require.resolve('@babel/plugin-transform-nullish-coalescing-operator'),\n  [\n    require.resolve('@babel/plugin-transform-template-literals'),\n    { loose: true },\n  ],\n];\n\nexport function makeWorkletFactory(\n  fun: NodePath<WorkletizableFunction>,\n  state: ReanimatedPluginPass\n): FunctionExpression {\n  // Returns a new FunctionExpression which is a workletized version of provided\n  // FunctionDeclaration, FunctionExpression, ArrowFunctionExpression or ObjectMethod.\n\n  removeWorkletDirective(fun);\n\n  // We use copy because some of the plugins don't update bindings and\n  // some even break them\n  assert(\n    state.file.opts.filename,\n    '[Reanimated] `state.file.opts.filename` is undefined.'\n  );\n\n  const codeObject = generate(fun.node, {\n    sourceMaps: true,\n    sourceFileName: state.file.opts.filename,\n  });\n\n  // We need to add a newline at the end, because there could potentially be a\n  // comment after the function that gets included here, and then the closing\n  // bracket would become part of the comment thus resulting in an error, since\n  // there is a missing closing bracket.\n  codeObject.code =\n    '(' + (fun.isObjectMethod() ? 'function ' : '') + codeObject.code + '\\n)';\n\n  const transformed = transformSync(codeObject.code, {\n    filename: state.file.opts.filename,\n    presets: workletStringTransformPresets,\n    plugins: workletStringTransformPlugins,\n    ast: true,\n    babelrc: false,\n    configFile: false,\n    inputSourceMap: codeObject.map,\n  });\n\n  assert(transformed, '[Reanimated] `transformed` is undefined.');\n  assert(transformed.ast, '[Reanimated] `transformed.ast` is undefined.');\n\n  const variables = makeArrayFromCapturedBindings(transformed.ast, fun);\n\n  const functionName = makeWorkletName(fun);\n  const functionIdentifier = identifier(functionName);\n\n  const clone = cloneNode(fun.node);\n  const funExpression = isBlockStatement(clone.body)\n    ? functionExpression(\n        null,\n        clone.params,\n        clone.body,\n        clone.generator,\n        clone.async\n      )\n    : clone;\n\n  let [funString, sourceMapString] = buildWorkletString(\n    transformed.ast,\n    variables,\n    functionName,\n    transformed.map\n  );\n  assert(funString, '[Reanimated] `funString` is undefined.');\n  const workletHash = hash(funString);\n\n  let lineOffset = 1;\n  if (variables.length > 0) {\n    // When worklet captures some variables, we append closure destructing at\n    // the beginning of the function body. This effectively results in line\n    // numbers shifting by the number of captured variables (size of the\n    // closure) + 2 (for the opening and closing brackets of the destruct\n    // statement)\n    lineOffset -= variables.length + 2;\n  }\n\n  const pathForStringDefinitions = fun.parentPath.isProgram()\n    ? fun\n    : fun.findParent((path) => path.parentPath?.isProgram() ?? false);\n  assert(\n    pathForStringDefinitions,\n    '[Reanimated] `pathForStringDefinitions` is null.'\n  );\n  assert(\n    pathForStringDefinitions.parentPath,\n    '[Reanimated] `pathForStringDefinitions.parentPath` is null.'\n  );\n\n  const initDataId =\n    pathForStringDefinitions.parentPath.scope.generateUidIdentifier(\n      `worklet_${workletHash}_init_data`\n    );\n\n  const initDataObjectExpression = objectExpression([\n    objectProperty(identifier('code'), stringLiteral(funString)),\n  ]);\n\n  // When testing with jest I noticed that environment variables are set later\n  // than some functions are evaluated. E.g. this cannot be above this function\n  // because it would always evaluate to true.\n  const shouldInjectLocation = !isRelease();\n  if (shouldInjectLocation) {\n    let location = state.file.opts.filename;\n    if (state.opts.relativeSourceLocation) {\n      location = relative(state.cwd, location);\n      // It seems there is no designated option to use relative paths in generated sourceMap\n      sourceMapString = sourceMapString?.replace(\n        state.file.opts.filename,\n        location\n      );\n    }\n\n    initDataObjectExpression.properties.push(\n      objectProperty(identifier('location'), stringLiteral(location))\n    );\n  }\n\n  if (sourceMapString) {\n    initDataObjectExpression.properties.push(\n      objectProperty(identifier('sourceMap'), stringLiteral(sourceMapString))\n    );\n  }\n\n  const shouldInjectVersion = !isRelease();\n  if (shouldInjectVersion) {\n    initDataObjectExpression.properties.push(\n      objectProperty(\n        identifier('version'),\n        stringLiteral(shouldMockVersion() ? MOCK_VERSION : REAL_VERSION)\n      )\n    );\n  }\n\n  const shouldIncludeInitData = !state.opts.omitNativeOnlyData;\n  if (shouldIncludeInitData) {\n    pathForStringDefinitions.insertBefore(\n      variableDeclaration('const', [\n        variableDeclarator(initDataId, initDataObjectExpression),\n      ])\n    );\n  }\n\n  assert(\n    !isFunctionDeclaration(funExpression),\n    '[Reanimated] `funExpression` is a `FunctionDeclaration`.'\n  );\n  assert(\n    !isObjectMethod(funExpression),\n    '[Reanimated] `funExpression` is an `ObjectMethod`.'\n  );\n\n  const statements: Array<\n    VariableDeclaration | ExpressionStatement | ReturnStatement\n  > = [\n    variableDeclaration('const', [\n      variableDeclarator(functionIdentifier, funExpression),\n    ]),\n    expressionStatement(\n      assignmentExpression(\n        '=',\n        memberExpression(functionIdentifier, identifier('__closure'), false),\n        objectExpression(\n          variables.map((variable) =>\n            objectProperty(identifier(variable.name), variable, false, true)\n          )\n        )\n      )\n    ),\n    expressionStatement(\n      assignmentExpression(\n        '=',\n        memberExpression(\n          functionIdentifier,\n          identifier('__workletHash'),\n          false\n        ),\n        numericLiteral(workletHash)\n      )\n    ),\n  ];\n\n  if (shouldIncludeInitData) {\n    statements.push(\n      expressionStatement(\n        assignmentExpression(\n          '=',\n          memberExpression(functionIdentifier, identifier('__initData'), false),\n          initDataId\n        )\n      )\n    );\n  }\n\n  if (!isRelease()) {\n    statements.unshift(\n      variableDeclaration('const', [\n        variableDeclarator(\n          identifier('_e'),\n          arrayExpression([\n            newExpression(\n              memberExpression(identifier('global'), identifier('Error')),\n              []\n            ),\n            numericLiteral(lineOffset),\n            numericLiteral(-27), // the placement of opening bracket after Exception in line that defined '_e' variable\n          ])\n        ),\n      ])\n    );\n    statements.push(\n      expressionStatement(\n        assignmentExpression(\n          '=',\n          memberExpression(\n            functionIdentifier,\n            identifier('__stackDetails'),\n            false\n          ),\n          identifier('_e')\n        )\n      )\n    );\n  }\n\n  statements.push(returnStatement(functionIdentifier));\n\n  const newFun = functionExpression(undefined, [], blockStatement(statements));\n\n  return newFun;\n}\n\nfunction removeWorkletDirective(fun: NodePath<WorkletizableFunction>): void {\n  fun.traverse({\n    DirectiveLiteral(path) {\n      if (path.node.value === 'worklet' && path.getFunctionParent() === fun) {\n        path.parentPath.remove();\n      }\n    },\n  });\n}\n\nfunction shouldMockVersion(): boolean {\n  // We don't want to pollute tests with current version number so we mock it\n  // for all tests (except one)\n  return process.env.REANIMATED_JEST_SHOULD_MOCK_VERSION === '1';\n}\n\nfunction hash(str: string): number {\n  let i = str.length;\n  let hash1 = 5381;\n  let hash2 = 52711;\n\n  while (i--) {\n    const char = str.charCodeAt(i);\n    // eslint-disable-next-line no-bitwise\n    hash1 = (hash1 * 33) ^ char;\n    // eslint-disable-next-line no-bitwise\n    hash2 = (hash2 * 33) ^ char;\n  }\n\n  // eslint-disable-next-line no-bitwise\n  return (hash1 >>> 0) * 4096 + (hash2 >>> 0);\n}\n\nfunction makeWorkletName(fun: NodePath<WorkletizableFunction>): string {\n  if (isObjectMethod(fun.node) && isIdentifier(fun.node.key)) {\n    return fun.node.key.name;\n  }\n  if (isFunctionDeclaration(fun.node) && isIdentifier(fun.node.id)) {\n    return fun.node.id.name;\n  }\n  if (isFunctionExpression(fun.node) && isIdentifier(fun.node.id)) {\n    return fun.node.id.name;\n  }\n  return 'anonymous'; // fallback for ArrowFunctionExpression and unnamed FunctionExpression\n}\n\nfunction makeArrayFromCapturedBindings(\n  ast: BabelFile,\n  fun: NodePath<WorkletizableFunction>\n): Identifier[] {\n  const closure = new Map<string, Identifier>();\n  const isLocationAssignedMap = new Map<string, boolean>();\n\n  // this traversal looks for variables to capture\n  traverse(ast, {\n    Identifier(path) {\n      // we only capture variables that were declared outside of the scope\n      if (!path.isReferencedIdentifier()) {\n        return;\n      }\n      const name = path.node.name;\n      // if the function is named and was added to globals we don't want to add it to closure\n      // hence we check if identifier has that name\n      if (globals.has(name)) {\n        return;\n      }\n      if (\n        'id' in fun.node &&\n        fun.node.id &&\n        fun.node.id.name === name // we don't want to capture function's own name\n      ) {\n        return;\n      }\n\n      const parentNode = path.parent;\n\n      if (\n        isMemberExpression(parentNode) &&\n        parentNode.property === path.node &&\n        !parentNode.computed\n      ) {\n        return;\n      }\n\n      if (\n        isObjectProperty(parentNode) &&\n        isObjectExpression(path.parentPath.parent) &&\n        path.node !== parentNode.value\n      ) {\n        return;\n      }\n\n      let currentScope = path.scope;\n\n      while (currentScope != null) {\n        if (currentScope.bindings[name] != null) {\n          return;\n        }\n        currentScope = currentScope.parent;\n      }\n      closure.set(name, path.node);\n      isLocationAssignedMap.set(name, false);\n    },\n  });\n\n  /*\n  For reasons I don't exactly understand, the above traversal will cause the whole \n  bundle to crash if we traversed original node instead of generated\n  AST. This is why we need to traverse it again, but this time we set\n  location for each identifier that was captured to their original counterpart, since\n  AST has its location set relative as if it was a separate file.\n  */\n  fun.traverse({\n    Identifier(path) {\n      // So it won't refer to something like:\n      // const obj = {unexistingVariable: 1};\n      if (!path.isReferencedIdentifier()) {\n        return;\n      }\n      const node = closure.get(path.node.name);\n      if (!node || isLocationAssignedMap.get(path.node.name)) {\n        return;\n      }\n      node.loc = path.node.loc;\n      isLocationAssignedMap.set(path.node.name, true);\n    },\n  });\n\n  return Array.from(closure.values());\n}\n", "import type { NodePath } from '@babel/core';\nimport { callExpression } from '@babel/types';\nimport type { CallExpression } from '@babel/types';\nimport type { ReanimatedPluginPass, WorkletizableFunction } from './types';\nimport { makeWorkletFactory } from './workletFactory';\n\nexport function makeWorkletFactoryCall(\n  path: NodePath<WorkletizableFunction>,\n  state: ReanimatedPluginPass\n): CallExpression {\n  const workletFactory = makeWorkletFactory(path, state);\n\n  const workletFactoryCall = callExpression(workletFactory, []);\n\n  addStackTraceDataToWorkletFactory(path, workletFactoryCall);\n\n  const replacement = workletFactoryCall;\n\n  return replacement;\n}\n\n/* \n  If for some reason the code of the worklet is so bad that it\n  causes the worklet factory to crash, eg.:\n\n  function foo() {\n    'worklet'\n    unexistingVariable;\n  };\n\n  Such function will cause the factory to crash on closure creation because\n  of reference to `unexistingVariable`.\n  \n  With this we are able to give a meaningful stack trace - we use `start` twice on purpose, since\n  crashing on the factory leads to its end on the stack trace - the closing bracket. It's more\n  approachable this way, when it points to the start of the original function.\n  */\nfunction addStackTraceDataToWorkletFactory(\n  path: NodePath<WorkletizableFunction>,\n  workletFactoryCall: CallExpression\n): void {\n  const originalWorkletLocation = path.node.loc;\n  if (originalWorkletLocation) {\n    workletFactoryCall.callee.loc = {\n      filename: originalWorkletLocation.filename,\n      identifierName: originalWorkletLocation.identifierName,\n      start: originalWorkletLocation.start,\n      end: originalWorkletLocation.start,\n    };\n  }\n}\n", "import type { NodePath } from '@babel/core';\nimport {\n  isBlockStatement,\n  isDirectiveLiteral,\n  objectProperty,\n  variableDeclaration,\n  variableDeclarator,\n  isScopable,\n  isExportNamedDeclaration,\n} from '@babel/types';\nimport type {\n  Directive,\n  ObjectMethod,\n  CallExpression,\n  FunctionDeclaration,\n} from '@babel/types';\nimport { makeWorkletFactoryCall } from './workletFactoryCall';\nimport type { ReanimatedPluginPass } from './types';\nimport { WorkletizableFunction } from './types';\n\n/**\n *\n * @returns `true` if the function was workletized, `false` otherwise.\n */\nexport function processIfWithWorkletDirective(\n  path: NodePath<WorkletizableFunction>,\n  state: ReanimatedPluginPass\n): boolean {\n  if (!isBlockStatement(path.node.body)) {\n    // If the function body is not a block statement we can safely assume that it's not a worklet\n    // since it's the case of an arrow function with immediate return\n    // eg. `const foo = () => 1;`\n    return false;\n  }\n  if (!hasWorkletDirective(path.node.body.directives)) {\n    return false;\n  }\n  processWorklet(path, state);\n  return true;\n}\n\n/**\n * Replaces\n * - `FunctionDeclaration`,\n * - `FunctionExpression`,\n * - `ArrowFunctionExpression`\n * - `ObjectMethod`\n *\n * with a workletized version of itself.\n */\nexport function processWorklet(\n  path: NodePath<WorkletizableFunction>,\n  state: ReanimatedPluginPass\n): void {\n  if (state.opts.processNestedWorklets) {\n    path.traverse(\n      {\n        // @ts-expect-error TypeScript doesn't like this syntax here.\n        [WorkletizableFunction](\n          subPath: NodePath<WorkletizableFunction>,\n          passedState: ReanimatedPluginPass\n        ): void {\n          processIfWithWorkletDirective(subPath, passedState);\n        },\n      },\n      state\n    );\n  }\n\n  const workletFactoryCall = makeWorkletFactoryCall(path, state);\n\n  substituteWithWorkletFactoryCall(path, workletFactoryCall);\n}\n\nfunction hasWorkletDirective(directives: Directive[]): boolean {\n  return directives.some(\n    (directive) =>\n      isDirectiveLiteral(directive.value) && directive.value.value === 'worklet'\n  );\n}\n\nfunction substituteWithWorkletFactoryCall(\n  path: NodePath<WorkletizableFunction>,\n  workletFactoryCall: CallExpression\n): void {\n  if (path.isObjectMethod()) {\n    substituteObjectMethodWithObjectProperty(path, workletFactoryCall);\n  } else if (path.isFunctionDeclaration()) {\n    maybeSubstituteFunctionDeclarationWithVariableDeclaration(\n      path,\n      workletFactoryCall\n    );\n  } else {\n    path.replaceWith(workletFactoryCall);\n  }\n}\n\nexport function substituteObjectMethodWithObjectProperty(\n  path: NodePath<ObjectMethod>,\n  workletFactoryCall: CallExpression\n): void {\n  const replacement = objectProperty(path.node.key, workletFactoryCall);\n  path.replaceWith(replacement);\n}\n\nexport function maybeSubstituteFunctionDeclarationWithVariableDeclaration(\n  path: NodePath<FunctionDeclaration>,\n  workletFactoryCall: CallExpression\n): void {\n  // We check if function needs to be assigned to variable declaration.\n  // This is needed if function definition directly in a scope. Some other ways\n  // where function definition can be used is for example with variable declaration:\n  //\n  // const bar = function foo() {'worklet' ...};\n  //\n  // In such a case we don't need to define variable for the function.\n  const needDeclaration =\n    isScopable(path.parent) || isExportNamedDeclaration(path.parent);\n\n  const replacement =\n    'id' in path.node && path.node.id && needDeclaration\n      ? variableDeclaration('const', [\n          variableDeclarator(path.node.id, workletFactoryCall),\n        ])\n      : workletFactoryCall;\n\n  path.replaceWith(replacement);\n}\n", "import type { NodePath } from '@babel/core';\nimport type { Expression } from '@babel/types';\nimport {\n  isIdentifier,\n  isCallExpression,\n  isMemberExpression,\n  isExpression,\n} from '@babel/types';\nimport type { WorkletizableFunction } from './types';\n\nconst gestureHandlerGestureObjects = new Set([\n  'Tap',\n  'Pan',\n  'Pinch',\n  'Rotation',\n  'Fling',\n  'LongPress',\n  'ForceTouch',\n  'Native',\n  'Manual',\n  'Race',\n  'Simultaneous',\n  'Exclusive',\n  'Hover',\n]);\n\nconst gestureHandlerBuilderMethods = new Set([\n  'onBegin',\n  'onStart',\n  'onEnd',\n  'onFinalize',\n  'onUpdate',\n  'onChange',\n  'onTouchesDown',\n  'onTouchesMove',\n  'onTouchesUp',\n  'onTouchesCancelled',\n]);\n\n// Auto-workletizes React Native Gesture Handler callback functions.\n// Detects `Gesture.Tap().onEnd(<fun>)` or similar, but skips `something.onEnd(<fun>)`.\n// Supports method chaining as well, e.g. `Gesture.Tap().onStart(<fun1>).onUpdate(<fun2>).onEnd(<fun3>)`.\n\n// Example #1: `Gesture.Tap().onEnd(<fun>)`\n/*\n  CallExpression(\n    callee: MemberExpression(\n      object: CallExpression(\n        callee: MemberExpression(\n          object: Identifier('Gesture')\n          property: Identifier('Tap')\n        )\n      )\n      property: Identifier('onEnd')\n    )\n    arguments: [fun]\n  )\n  */\n\n// Example #2: `Gesture.Tap().onStart(<fun1>).onUpdate(<fun2>).onEnd(<fun3>)`\n/*\n  CallExpression(\n    callee: MemberExpression(\n      object: CallExpression(\n        callee: MemberExpression(\n          object: CallExpression(\n            callee: MemberExpression(\n              object: CallExpression(\n                callee: MemberExpression(\n                  object: Identifier('Gesture')\n                  property: Identifier('Tap')\n                )\n              )\n              property: Identifier('onStart')\n            )\n            arguments: [fun1]\n          )\n          property: Identifier('onUpdate')\n        )\n        arguments: [fun2]\n      )\n      property: Identifier('onEnd')\n    )\n    arguments: [fun3]\n  )\n  */\nexport function isGestureHandlerEventCallback(\n  path: NodePath<WorkletizableFunction>\n): boolean {\n  return (\n    isCallExpression(path.parent) &&\n    isExpression(path.parent.callee) &&\n    isGestureObjectEventCallbackMethod(path.parent.callee)\n  );\n}\n\nfunction isGestureObjectEventCallbackMethod(exp: Expression): boolean {\n  // Checks if node matches the pattern `Gesture.Foo()[*].onBar`\n  // where `[*]` represents any number of method calls.\n  return (\n    isMemberExpression(exp) &&\n    isIdentifier(exp.property) &&\n    gestureHandlerBuilderMethods.has(exp.property.name) &&\n    containsGestureObject(exp.object)\n  );\n}\n\nfunction containsGestureObject(exp: Expression): boolean {\n  // Checks if node matches the pattern `Gesture.Foo()[*]`\n  // where `[*]` represents any number of chained method calls, like `.something(42)`.\n\n  // direct call\n  if (isGestureObject(exp)) {\n    return true;\n  }\n\n  // method chaining\n  if (\n    isCallExpression(exp) &&\n    isMemberExpression(exp.callee) &&\n    containsGestureObject(exp.callee.object)\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isGestureObject(exp: Expression): boolean {\n  // Checks if node matches `Gesture.Tap()` or similar.\n  /*\n  node: CallExpression(\n    callee: MemberExpression(\n      object: Identifier('Gesture')\n      property: Identifier('Tap')\n    )\n  )\n  */\n  return (\n    isCallExpression(exp) &&\n    isMemberExpression(exp.callee) &&\n    isIdentifier(exp.callee.object) &&\n    exp.callee.object.name === 'Gesture' &&\n    isIdentifier(exp.callee.property) &&\n    gestureHandlerGestureObjects.has(exp.callee.property.name)\n  );\n}\n", "import type { NodePath } from '@babel/core';\nimport type { Expression } from '@babel/types';\nimport {\n  isIdentifier,\n  isCallExpression,\n  isMemberExpression,\n  isExpression,\n  isNewExpression,\n} from '@babel/types';\nimport type { WorkletizableFunction } from './types';\n\nconst EntryExitAnimations = new Set([\n  'BounceIn',\n  'BounceInDown',\n  'BounceInLeft',\n  'BounceInRight',\n  'BounceInUp',\n  'BounceOut',\n  'BounceOutDown',\n  'BounceOutLeft',\n  'BounceOutRight',\n  'BounceOutUp',\n  'FadeIn',\n  'FadeInDown',\n  'FadeInLeft',\n  'FadeInRight',\n  'FadeInUp',\n  'FadeOut',\n  'FadeOutDown',\n  'FadeOutLeft',\n  'FadeOutRight',\n  'FadeOutUp',\n  'FlipInEasyX',\n  'FlipInEasyY',\n  'FlipInXDown',\n  'FlipInXUp',\n  'FlipInYLeft',\n  'FlipInYRight',\n  'FlipOutEasyX',\n  'FlipOutEasyY',\n  'FlipOutXDown',\n  'FlipOutXUp',\n  'FlipOutYLeft',\n  'FlipOutYRight',\n  'LightSpeedInLeft',\n  'LightSpeedInRight',\n  'LightSpeedOutLeft',\n  'LightSpeedOutRight',\n  'PinwheelIn',\n  'PinwheelOut',\n  'RollInLeft',\n  'RollInRight',\n  'RollOutLeft',\n  'RollOutRight',\n  'RotateInDownLeft',\n  'RotateInDownRight',\n  'RotateInUpLeft',\n  'RotateInUpRight',\n  'RotateOutDownLeft',\n  'RotateOutDownRight',\n  'RotateOutUpLeft',\n  'RotateOutUpRight',\n  'SlideInDown',\n  'SlideInLeft',\n  'SlideInRight',\n  'SlideInUp',\n  'SlideOutDown',\n  'SlideOutLeft',\n  'SlideOutRight',\n  'SlideOutUp',\n  'StretchInX',\n  'StretchInY',\n  'StretchOutX',\n  'StretchOutY',\n  'ZoomIn',\n  'ZoomInDown',\n  'ZoomInEasyDown',\n  'ZoomInEasyUp',\n  'ZoomInLeft',\n  'ZoomInRight',\n  'ZoomInRotate',\n  'ZoomInUp',\n  'ZoomOut',\n  'ZoomOutDown',\n  'ZoomOutEasyDown',\n  'ZoomOutEasyUp',\n  'ZoomOutLeft',\n  'ZoomOutRight',\n  'ZoomOutRotate',\n  'ZoomOutUp',\n]);\n\nconst LayoutTransitions = new Set([\n  'Layout',\n  'LinearTransition',\n  'SequencedTransition',\n  'FadingTransition',\n  'JumpingTransition',\n  'CurvedTransition',\n  'EntryExitTransition',\n]);\n\nconst LayoutAnimations = new Set([\n  ...EntryExitAnimations,\n  ...LayoutTransitions,\n]);\n\nconst BaseAnimationsChainableMethods = new Set([\n  'build',\n  'duration',\n  'delay',\n  'getDuration',\n  'randomDelay',\n  'getDelay',\n  'getDelayFunction',\n]);\n\nconst ComplexAnimationsChainableMethods = new Set([\n  'easing',\n  'rotate',\n  'springify',\n  'damping',\n  'mass',\n  'stiffness',\n  'overshootClamping',\n  'restDisplacementThreshold',\n  'restSpeedThreshold',\n  'withInitialValues',\n  'getAnimationAndConfig',\n]);\n\nconst DefaultTransitionChainableMethods = new Set([\n  'easingX',\n  'easingY',\n  'easingWidth',\n  'easingHeight',\n  'entering',\n  'exiting',\n  'reverse',\n]);\n\nconst LayoutAnimationsChainableMethods = new Set([\n  ...BaseAnimationsChainableMethods,\n  ...ComplexAnimationsChainableMethods,\n  ...DefaultTransitionChainableMethods,\n]);\n\nconst LayoutAnimationsCallbacks = new Set(['withCallback']);\n\nexport function isLayoutAnimationCallback(\n  path: NodePath<WorkletizableFunction>\n): boolean {\n  return (\n    isCallExpression(path.parent) &&\n    isExpression(path.parent.callee) &&\n    isLayoutAnimationCallbackMethod(path.parent.callee)\n  );\n}\n\nfunction isLayoutAnimationCallbackMethod(exp: Expression): boolean {\n  return (\n    isMemberExpression(exp) &&\n    isIdentifier(exp.property) &&\n    LayoutAnimationsCallbacks.has(exp.property.name) &&\n    isLayoutAnimationsChainableOrNewOperator(exp.object)\n  );\n}\n\nfunction isLayoutAnimationsChainableOrNewOperator(exp: Expression): boolean {\n  if (isIdentifier(exp) && LayoutAnimations.has(exp.name)) {\n    return true;\n  } else if (\n    isNewExpression(exp) &&\n    isIdentifier(exp.callee) &&\n    LayoutAnimations.has(exp.callee.name)\n  ) {\n    return true;\n  }\n  if (\n    isCallExpression(exp) &&\n    isMemberExpression(exp.callee) &&\n    isIdentifier(exp.callee.property) &&\n    LayoutAnimationsChainableMethods.has(exp.callee.property.name) &&\n    isLayoutAnimationsChainableOrNewOperator(exp.callee.object)\n  ) {\n    return true;\n  }\n\n  return false;\n}\n", "import type { NodePath } from '@babel/core';\nimport type { AssignmentExpression, Identifier } from '@babel/types';\nimport {\n  isWorkletizableFunctionType,\n  isWorkletizableObjectType,\n} from './types';\nimport type { WorkletizableFunction, WorkletizableObject } from './types';\nimport type { Binding } from '@babel/traverse';\n\nexport function findReferencedWorklet(\n  workletIdentifier: NodePath<Identifier>,\n  acceptWorkletizableFunction: boolean,\n  acceptObject: boolean\n): NodePath<WorkletizableFunction> | NodePath<WorkletizableObject> | undefined {\n  const workletName = workletIdentifier.node.name;\n  const scope = workletIdentifier.scope;\n\n  const workletBinding = scope.getBinding(workletName);\n  if (!workletBinding) {\n    return undefined;\n  }\n\n  if (\n    acceptWorkletizableFunction &&\n    workletBinding.path.isFunctionDeclaration()\n  ) {\n    return workletBinding.path;\n  }\n\n  const isConstant = workletBinding.constant;\n  if (isConstant) {\n    return findReferencedWorkletFromVariableDeclarator(\n      workletBinding,\n      acceptWorkletizableFunction,\n      acceptObject\n    );\n  }\n  return findReferencedWorkletFromAssignmentExpression(\n    workletBinding,\n    acceptWorkletizableFunction,\n    acceptObject\n  );\n}\n\nfunction findReferencedWorkletFromVariableDeclarator(\n  workletBinding: Binding,\n  acceptWorkletizableFunction: boolean,\n  acceptObject: boolean\n): NodePath<WorkletizableFunction> | NodePath<WorkletizableObject> | undefined {\n  const workletDeclaration = workletBinding.path;\n  if (!workletDeclaration.isVariableDeclarator()) {\n    return undefined;\n  }\n  const worklet = workletDeclaration.get('init');\n\n  if (acceptWorkletizableFunction && isWorkletizableFunctionType(worklet)) {\n    return worklet;\n  }\n  if (acceptObject && isWorkletizableObjectType(worklet)) {\n    return worklet;\n  }\n  return undefined;\n}\n\nfunction findReferencedWorkletFromAssignmentExpression(\n  workletBinding: Binding,\n  acceptWorkletizableFunction: boolean,\n  acceptObject: boolean\n): NodePath<WorkletizableFunction> | NodePath<WorkletizableObject> | undefined {\n  const workletDeclaration = workletBinding.constantViolations\n    .reverse()\n    .find(\n      (constantViolation) =>\n        constantViolation.isAssignmentExpression() &&\n        ((acceptWorkletizableFunction &&\n          isWorkletizableFunctionType(constantViolation.get('right'))) ||\n          (acceptObject &&\n            isWorkletizableObjectType(constantViolation.get('right'))))\n    ) as NodePath<AssignmentExpression> | undefined;\n\n  if (!workletDeclaration || !workletDeclaration.isAssignmentExpression()) {\n    return undefined;\n  }\n\n  const workletDefinition = workletDeclaration.get('right');\n\n  if (\n    acceptWorkletizableFunction &&\n    isWorkletizableFunctionType(workletDefinition)\n  ) {\n    return workletDefinition;\n  }\n  if (acceptObject && isWorkletizableObjectType(workletDefinition)) {\n    return workletDefinition;\n  }\n  return undefined;\n}\n", "import type { NodePath } from '@babel/core';\nimport { isWorkletizableFunctionType } from './types';\nimport type { WorkletizableObject, ReanimatedPluginPass } from './types';\nimport { processWorklet } from './workletSubstitution';\n\nexport function processWorkletizableObject(\n  path: NodePath<WorkletizableObject>,\n  state: ReanimatedPluginPass\n): void {\n  const properties = path.get('properties');\n  for (const property of properties) {\n    if (property.isObjectMethod()) {\n      processWorklet(property, state);\n    } else if (property.isObjectProperty()) {\n      const value = property.get('value');\n      if (isWorkletizableFunctionType(value)) {\n        processWorklet(value, state);\n      }\n    } else {\n      throw new Error(\n        `[Reanimated] '${property.type}' as to-be workletized argument is not supported for object hooks.`\n      );\n    }\n  }\n}\n", "import type { NodePath } from '@babel/core';\nimport type { CallExpression } from '@babel/types';\nimport { isSequenceExpression } from '@babel/types';\nimport {\n  isWorkletizableFunctionType,\n  isWorkletizableObjectType,\n} from './types';\nimport type {\n  WorkletizableFunction,\n  WorkletizableObject,\n  ReanimatedPluginPass,\n} from './types';\nimport { processWorklet } from './workletSubstitution';\nimport { isGestureHandlerEventCallback } from './gestureHandlerAutoworkletization';\nimport { isLayoutAnimationCallback } from './layoutAnimationAutoworkletization';\nimport { findReferencedWorklet } from './referencedWorklets';\nimport { processWorkletizableObject } from './objectWorklets';\n\nconst objectHooks = new Set([\n  'useAnimatedGestureHandler',\n  'useAnimatedScrollHandler',\n]);\n\nconst functionHooks = new Set([\n  'useFrameCallback',\n  'useAnimatedStyle',\n  'useAnimatedProps',\n  'createAnimatedPropAdapter',\n  'useDerivedValue',\n  'useAnimatedScrollHandler',\n  'useAnimatedReaction',\n  'useWorkletCallback',\n  // animations' callbacks\n  'withTiming',\n  'withSpring',\n  'withDecay',\n  'withRepeat',\n  // scheduling functions\n  'runOnUI',\n  'executeOnUIRuntimeSync',\n]);\n\nconst functionArgsToWorkletize = new Map([\n  ['useAnimatedGestureHandler', [0]],\n  ['useFrameCallback', [0]],\n  ['useAnimatedStyle', [0]],\n  ['useAnimatedProps', [0]],\n  ['createAnimatedPropAdapter', [0]],\n  ['useDerivedValue', [0]],\n  ['useAnimatedScrollHandler', [0]],\n  ['useAnimatedReaction', [0, 1]],\n  ['useWorkletCallback', [0]],\n  ['withTiming', [2]],\n  ['withSpring', [2]],\n  ['withDecay', [1]],\n  ['withRepeat', [3]],\n  ['runOnUI', [0]],\n  ['executeOnUIRuntimeSync', [0]],\n]);\n\n/**\n *\n * @returns `true` if the function was workletized, `false` otherwise.\n */\nexport function processIfAutoworkletizableCallback(\n  path: NodePath<WorkletizableFunction>,\n  state: ReanimatedPluginPass\n): boolean {\n  if (isGestureHandlerEventCallback(path) || isLayoutAnimationCallback(path)) {\n    processWorklet(path, state);\n    return true;\n  }\n  return false;\n}\n\nexport function processCalleesAutoworkletizableCallbacks(\n  path: NodePath<CallExpression>,\n  state: ReanimatedPluginPass\n): void {\n  const callee = isSequenceExpression(path.node.callee)\n    ? path.node.callee.expressions[path.node.callee.expressions.length - 1]\n    : path.node.callee;\n\n  // We are looking for objects we know we should workletize\n  // hence if object is not named, we return.\n  const name =\n    'name' in callee\n      ? callee.name\n      : 'property' in callee && 'name' in callee.property\n      ? callee.property.name\n      : undefined;\n  if (name === undefined) {\n    return;\n  }\n\n  if (functionHooks.has(name) || objectHooks.has(name)) {\n    const acceptWorkletizableFunction = functionHooks.has(name);\n    const acceptObject = objectHooks.has(name);\n    const argIndices = functionArgsToWorkletize.get(name)!;\n    const args = path\n      .get('arguments')\n      .filter((_, index) => argIndices.includes(index));\n\n    processArgs(args, state, acceptWorkletizableFunction, acceptObject);\n  }\n}\n\nfunction processArgs(\n  args: NodePath[],\n  state: ReanimatedPluginPass,\n  acceptWorkletizableFunction: boolean,\n  acceptObject: boolean\n): void {\n  args.forEach((arg) => {\n    const maybeWorklet = findWorklet(\n      arg,\n      acceptWorkletizableFunction,\n      acceptObject\n    );\n    if (!maybeWorklet) {\n      return;\n    }\n    if (isWorkletizableFunctionType(maybeWorklet)) {\n      processWorklet(maybeWorklet, state);\n    } else if (isWorkletizableObjectType(maybeWorklet)) {\n      processWorkletizableObject(maybeWorklet, state);\n    }\n  });\n}\n\nfunction findWorklet(\n  arg: NodePath,\n  acceptWorkletizableFunction: boolean,\n  acceptObject: boolean\n): NodePath<WorkletizableFunction> | NodePath<WorkletizableObject> | undefined {\n  if (acceptWorkletizableFunction && isWorkletizableFunctionType(arg)) {\n    return arg;\n  }\n  if (acceptObject && isWorkletizableObjectType(arg)) {\n    return arg;\n  }\n  if (arg.isReferencedIdentifier() && arg.isIdentifier()) {\n    return findReferencedWorklet(\n      arg,\n      acceptWorkletizableFunction,\n      acceptObject\n    );\n  }\n  return undefined;\n}\n", "import type { NodePath } from '@babel/core';\nimport type {\n  MemberExpression,\n  ObjectExpression,\n  JSXAttribute,\n  ObjectProperty,\n} from '@babel/types';\nimport {\n  callExpression,\n  arrowFunctionExpression,\n  isArrayExpression,\n  isJSXExpressionContainer,\n  identifier,\n  stringLiteral,\n  expressionStatement,\n  memberExpression,\n  returnStatement,\n  blockStatement,\n  isIdentifier,\n} from '@babel/types';\nimport { isRelease } from './utils';\nimport type { ReanimatedPluginPass } from './types';\nimport { strict as assert } from 'assert';\n\nfunction generateInlineStylesWarning(path: NodePath<MemberExpression>) {\n  // replaces `sharedvalue.value` with `(()=>{console.warn(require('react-native-reanimated').getUseOfValueInStyleWarning());return sharedvalue.value;})()`\n  return callExpression(\n    arrowFunctionExpression(\n      [],\n      blockStatement([\n        expressionStatement(\n          callExpression(\n            memberExpression(identifier('console'), identifier('warn')),\n            [\n              callExpression(\n                memberExpression(\n                  callExpression(identifier('require'), [\n                    stringLiteral('react-native-reanimated'),\n                  ]),\n                  identifier('getUseOfValueInStyleWarning')\n                ),\n                []\n              ),\n            ]\n          )\n        ),\n        returnStatement(path.node),\n      ])\n    ),\n    []\n  );\n}\n\nfunction processPropertyValueForInlineStylesWarning(\n  path: NodePath<ObjectProperty['value']>\n) {\n  // if it's something like object.value then raise a warning\n  if (path.isMemberExpression() && isIdentifier(path.node.property)) {\n    if (path.node.property.name === 'value') {\n      path.replaceWith(generateInlineStylesWarning(path));\n    }\n  }\n}\n\nfunction processTransformPropertyForInlineStylesWarning(\n  path: NodePath<ObjectProperty['value']>\n) {\n  if (isArrayExpression(path.node)) {\n    const elements = path.get('elements');\n    assert(\n      Array.isArray(elements),\n      '[Reanimated] `elements` should be an array.'\n    );\n    for (const element of elements) {\n      if (element.isObjectExpression()) {\n        processStyleObjectForInlineStylesWarning(element);\n      }\n    }\n  }\n}\n\nfunction processStyleObjectForInlineStylesWarning(\n  path: NodePath<ObjectExpression>\n) {\n  const properties = path.get('properties');\n  for (const property of properties) {\n    if (property.isObjectProperty()) {\n      const value = property.get('value');\n      if (\n        isIdentifier(property.node.key) &&\n        property.node.key.name === 'transform'\n      ) {\n        processTransformPropertyForInlineStylesWarning(value);\n      } else {\n        processPropertyValueForInlineStylesWarning(value);\n      }\n    }\n  }\n}\n\nexport function processInlineStylesWarning(\n  path: NodePath<JSXAttribute>,\n  state: ReanimatedPluginPass\n) {\n  if (isRelease()) {\n    return;\n  }\n  if (state.opts.disableInlineStylesWarning) {\n    return;\n  }\n  if (path.node.name.name !== 'style') {\n    return;\n  }\n  if (!isJSXExpressionContainer(path.node.value)) {\n    return;\n  }\n\n  const expression = path.get('value').get('expression');\n  // style={[{...}, {...}]}\n  assert(\n    !Array.isArray(expression),\n    '[Reanimated] `expression` should not be an array.'\n  );\n  if (expression.isArrayExpression()) {\n    const elements = expression.get('elements');\n    assert(\n      Array.isArray(elements),\n      '[Reanimated] `elements` should be an array.'\n    );\n    for (const element of elements) {\n      if (element.isObjectExpression()) {\n        processStyleObjectForInlineStylesWarning(element);\n      }\n    }\n  }\n  // style={{...}}\n  else if (expression.isObjectExpression()) {\n    processStyleObjectForInlineStylesWarning(expression);\n  }\n}\n", "import type { NodePath } from '@babel/core';\nimport { booleanLiteral, isIdentifier } from '@babel/types';\nimport type { CallExpression } from '@babel/types';\n\nexport function substituteWebCallExpression(path: NodePath<CallExpression>) {\n  const callee = path.node.callee;\n  if (isIdentifier(callee)) {\n    const name = callee.name;\n    if (name === 'isWeb' || name === 'shouldBeUseWeb') {\n      path.replaceWith(booleanLiteral(true));\n    }\n  }\n}\n", "import type { PluginItem, NodePath } from '@babel/core';\nimport type { CallExpression } from '@babel/types';\nimport {\n  processIfAutoworkletizableCallback,\n  processCalleesAutoworkletizableCallbacks,\n} from './autoworkletization';\nimport { WorkletizableFunction } from './types';\nimport type { ReanimatedPluginPass } from './types';\nimport { processIfWithWorkletDirective } from './workletSubstitution';\nimport { processInlineStylesWarning } from './inlineStylesWarning';\nimport { addCustomGlobals } from './utils';\nimport { initializeGlobals } from './globals';\nimport { substituteWebCallExpression } from './webOptimization';\n\nmodule.exports = function (): PluginItem {\n  function runWithTaggedExceptions(fun: () => void) {\n    try {\n      fun();\n    } catch (e) {\n      throw new Error(`[Reanimated] Babel plugin exception: ${e as string}`);\n    }\n  }\n\n  return {\n    pre() {\n      runWithTaggedExceptions(() => {\n        initializeGlobals();\n        addCustomGlobals.call(this);\n      });\n    },\n    visitor: {\n      CallExpression: {\n        enter(path: NodePath<CallExpression>, state: ReanimatedPluginPass) {\n          runWithTaggedExceptions(() => {\n            processCalleesAutoworkletizableCallbacks(path, state);\n            if (state.opts.substituteWebPlatformChecks) {\n              substituteWebCallExpression(path);\n            }\n          });\n        },\n      },\n      [WorkletizableFunction]: {\n        enter(\n          path: NodePath<WorkletizableFunction>,\n          state: ReanimatedPluginPass\n        ) {\n          runWithTaggedExceptions(() => {\n            processIfWithWorkletDirective(path, state) ||\n              processIfAutoworkletizableCallback(path, state);\n          });\n        },\n      },\n      JSXAttribute: {\n        enter(path, state) {\n          runWithTaggedExceptions(() =>\n            processInlineStylesWarning(path, state)\n          );\n        },\n      },\n    },\n  };\n};\n"],
  "mappings": "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AAe;AAUtC,cACE,GAAAA,SAAA,kBAAiB,GAAG,MACpB,GAAAA,SAAA,oBAAmB,IAAI,MAAM,MAC7B,GAAAA,SAAA,cAAa,IAAI,OAAO,MAAM,KAC9B,IAAI,OAAO,OAAO,SAAS,cAC3B,GAAAA,SAAA,cAAa,IAAI,OAAO,QAAQ,KAChC,6BAA6B,IAAI,IAAI,OAAO,SAAS,IAAI;IAE7D;;;;;;;;;;AChJA,QAAAE,WAAA,QAAA,cAAA;AASA,QAAM,sBAAsB,oBAAI,IAAI;MAClC;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;KACD;AAED,QAAM,oBAAoB,oBAAI,IAAI;MAChC;MACA;MACA;MACA;MACA;MACA;MACA;KACD;AAED,QAAM,mBAAmB,oBAAI,IAAI;MAC/B,GAAG;MACH,GAAG;KACJ;AAED,QAAM,iCAAiC,oBAAI,IAAI;MAC7C;MACA;MACA;MACA;MACA;MACA;MACA;KACD;AAED,QAAM,oCAAoC,oBAAI,IAAI;MAChD;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;KACD;AAED,QAAM,oCAAoC,oBAAI,IAAI;MAChD;MACA;MACA;MACA;MACA;MACA;MACA;KACD;AAED,QAAM,mCAAmC,oBAAI,IAAI;MAC/C,GAAG;MACH,GAAG;MACH,GAAG;KACJ;AAED,QAAM,4BAA4B,oBAAI,IAAI,CAAC,cAAc,CAAC;AAE1D,aAAgB,0BACd,MAAqC;AAErC,cACE,GAAAA,SAAA,kBAAiB,KAAK,MAAM,MAC5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",
  "names": ["exports", "exports", "globals_1", "exports", "types_1", "utils_1", "exports", "types_1", "globals_1", "utils_1", "exports", "types_1", "exports", "types_1", "exports", "types_1", "exports", "types_1", "exports", "types_1", "exports", "types_1", "workletSubstitution_1", "exports", "types_1", "workletSubstitution_1", "exports", "types_1", "utils_1", "exports", "types_1", "exports"]
}
